
##
## By Elim Thompson (11/23/2020)
##
## This script encapsulates a patient class, storing information related
## to interrupting status, disease (radiologist diagnosis) status, AI call,
## and timestamps including trigger (arrival) time, radiologist's reading
## time, waiting time, total time in system, etc. Each patient has a unique
## ID based on the arrival time, which is used to compare one patient to another.
##
## 05/05/2023
## ----------
## * Add in properties for multi-AI scenario
##
## 07/24/2023 by Rucha
## ----------
## * Update for hierarchical queuing (multi-disease, multi-AI, independent
##   disease groups scenario).
## * Hier_class_dict and property hier_class are now added.
##
## 05/21/2024
## ----------
## * Add in comments about hier_classes
###########################################################################

################################
## Import packages
################################ 
import numpy, pandas
from copy import deepcopy

################################
## Define constants
################################

################################
## Short functions
################################
get_caseID = lambda n: str (n).zfill (7)
minutes_to_microsec = lambda minute: round (minute * 60 * 10**3 * 10**3)

################################
## Define patient class
################################
class patient (object):
    
    def __init__ (self, index, diseaseGroups, fractionED, arrivalRate, last_patient_time,
                  hierarchyDict):
        
        ''' A patient needs several inputs to determine the interrupting status, disease
            (truth) status (if applicable), and arrival time. Emergency status is a
            random number (0 or 1) from a binomial distribution based on the interrupting
            fraction (fractionED). Disease (truth) status is the same based on the
            disease prevalence. The arrival time is the previous patient arrival time
            plus a random number generated from an exponential distribution with the
            input arrival rate. 
            
            Both AI call (if applicable) and radiologist's reading (service) time will 
            be determined after the patient instance is initialized.
            
            inputs
            ------
            index (int): A unique patient ID based on the order of arrival time.
            diseaseGroups (dict): Fractions of each group and target disease. e.g.
                                  {'AI1':{'groupProb':0.4, 'diseaseNames':['A'], 'diseaseProbs':[0.3]},
                                   'noAI':{'groupProb':0.6, 'diseaseNames':['F'], 'diseaseProbs':[0.6]}}
            fractionED (float): Fraction of emergent patients with respect to the
                                total number of patients (i.e. number of emergent
                                patients / number of all patients)
            arrivalRate (float): The overall arrival rate of all patient subgroups
                                 in the unit of 1/minute (i.e. number of patient
                                 arrival / time period)
            last_patient_time (pandas.datetime): Arrival time of previous patient 
            hierarchyDict (dict): hierarchy ranking of AIs. Always start from 3.
                                  {'Vendor1':3, 'Vendor2':4, 'Vendor3':5}
        '''
        
        # A unique ID in string for this patient
        self._caseID = get_caseID (index)
        
        # Holders to store timestamps at which this patient image is opened and closed.
        # A case could be opened or closed many times when it is interrupted more than once.
        self._open_times = []
        self._close_times = []
        
        # Holder to store the doctors that handle this patient image. When a case is
        # opened several times, it can be handled by different doctors.  
        self._doctors = []

        # Emergency status, disease status, and AI call of this patient 
        self._is_interrupting = bool (numpy.random.binomial (1, fractionED))
        self._group_name = None
        self._disease_name = None
        self._is_positive = None # flagged by any AI
        self._is_positives = {} # storing decision from each AI
        self._priority_class = None
        self._hierarchy_class = None

        self._is_diseased = None # if self._is_interrupting 
        self._is_positive = None # will be generated by AI

        self._interrupted_by = []
        
        if not self._is_interrupting:
            # 1. which group this patient is in
            groupProbs = [groupInfo['groupProb'] for _, groupInfo in diseaseGroups.items()]
            groupIndex = numpy.random.multinomial (1, groupProbs, size=1)[0]
            self._group_name = numpy.array (list (diseaseGroups.keys()))[numpy.where (groupIndex==1)][0]
            # 2. which disease condition does this patient has
            prevalences = deepcopy (diseaseGroups[self._group_name]['diseaseProbs'])
            prevalences += [1-sum (prevalences)]
            diseaseNames = diseaseGroups[self._group_name]['diseaseNames'] + ['non-diseased']
            diseaseIndex = numpy.random.multinomial (1, prevalences, size=1)[0]
            self._disease_name = numpy.array (diseaseNames)[numpy.where (diseaseIndex==1)][0]

        # Determine the arrival time of this patient 
        # 1. Average interarrival time is needed to define an exponential distribution in
        #    order to generate the interarrival time for this patient 
        self._meanInterarrivalTime = 1/arrivalRate
        # 2. Randomly generate the interarrival time from the exponential curve
        from_last_arrival = minutes_to_microsec (self._get_interarrival_time())
        # 3. Arrival time is the arrival time of previous patient plus the interarrival time 
        self._trigger_time = last_patient_time + pandas.offsets.Micro (from_last_arrival)
        
        # How long does this patient take to be served? For the purpose of debugging, two
        # private variables are defined which should be identical if simulation is running
        # corrected. Both are in minutes.
        self._assigned_serviceTime = None # assigned at patient arrival
        self._service_duration = None     # service time based on open_times and close_times 

    def __eq__ (self, other):
        return self.caseID == other.caseID

    def __ne__ (self, other):
        return not self.caseID == other.caseID
    
    def __lt__ (self, other):
        return self.caseID < other.caseID
    
    def __le__ (self, other):
        return self.caseID <= other.caseID
        
    def __gt__ (self, other):
        return self.caseID > other.caseID

    def __ge__ (self, other):
        return self.caseID >= other.caseID    
    
    def _print_summary_line (self, header, value, laster=None):
        if value is None: return ''
        if laster is None:
            return '|   * {0} {1}\n'.format (header, value)
        return '|   * {0} {1} {2}\n'.format (header, value, laster)
        
    def __str__ (self):
        summary  = '+----------------------------------------------\n'
        summary += '| Patient ({0}):\n'.format (self.caseID)
        summary += '|   * Is interrupting  ? {0}\n'.format (self.is_interrupting)
        if self._disease_name is not None:
            summary += '|   * Which group ? {0}\n'.format (self.group_name)
            summary += '|   * Which condition ? {0}\n'.format (self.disease_name)        

        if self.is_positive is not None:
            summary += '|   * Is positive   ? {0}\n'.format (self.is_positive)
        summary += '|   * Priority class? {0}\n'.format (self.priority_class)
        summary += '|  Time stamp ...\n'
        summary += self._print_summary_line ('Arrived at', self.trigger_time)
        for time in self.open_times:
            summary += self._print_summary_line ('Served  at', time)
        for time in self.close_times:
            summary += self._print_summary_line ('Left    at', time)
        for name in self._doctors:
            summary += self._print_summary_line ('Visited by', name)
        summary += '|  Duration ...\n'
        summary += self._print_summary_line ('Waited for', self.wait_time_duration, laster='min')
        summary += self._print_summary_line ('Served for', self.service_duration, laster='min')
        summary += self._print_summary_line ('Total  for', self.total_time_duration, laster='min')
        return summary
        
    def __repr__ (self): return self.caseID

    @property
    def caseID (self): return self._caseID
    
    @property
    def arrivalRate (self): return 1/self._meanInterarrivalTime     
    
    @property
    def trigger_time (self): return self._trigger_time

    @property
    def assigned_service_time (self): return self._assigned_serviceTime
    @assigned_service_time.setter
    def assigned_service_time (self, service_time):
        self._assigned_serviceTime = service_time
    
    @property
    def open_times (self): return self._open_times

    @property
    def latest_open_time (self): return self._open_times[-1]
    
    @property
    def close_times (self): return self._close_times

    @property
    def doctors (self):
        if len (self._doctors) == 0: return None
        return self._doctors

    @property
    def latest_close_time (self): return self._close_times[-1]

    @property
    def latest_doctor (self):
        if len (self._doctors) == 0: return None
        return self._doctors[-1] 

    @property
    def service_duration (self): return self._service_duration
    @service_duration.setter    
    def service_duration (self, service_duration):
        self._service_duration = service_duration # minutes    
    
    @property
    def total_service_duration (self):
        
        ''' Total service duration is the sum of the differences
            between open and close times.
        '''
        
        total_min = 0
        for (o, c) in zip (self._open_times, self._close_times):
            dt = c - o
            total_min += dt.total_seconds()/60.
        return total_min
    
    @property
    def wait_time_duration (self):
        
        ''' Wait time of a patient is the sum of 
            1. arrival time to first open time
            2. differences between previous close time and next open time
        '''
        
        if len (self._open_times)==0: return None
        waiting = 0
        for index, time in enumerate (self._open_times):
            begin = self._trigger_time if index == 0 else self._close_times[index-1]
            waiting += (time - begin).total_seconds() 
        return waiting / 60.

    @property
    def total_time_duration (self):
        
        ''' Total time in the system i.e. difference between the
            last close time and arrival (trigger) time. 
        '''
        
        if len (self._close_times) == 0: return None
        return (self._close_times[-1] - self._trigger_time).total_seconds() / 60.
    
    @property
    def disease_name (self): return self._disease_name
    
    @property
    def group_name (self): return self._group_name  

    @property
    def is_interrupting (self): return self._is_interrupting

    @property
    def is_diseased (self):
        if self.is_interrupting: return False
        return not self._disease_name == 'non-diseased' 

    @property
    def is_positive (self): return self._is_positive
    @is_positive.setter
    def is_positive (self, is_positive): self._is_positive = is_positive

    @property
    def is_positives (self): return self._is_positives
    @is_positives.setter
    def is_positives (self, is_positives_dict):
        self._is_positives = is_positives_dict

    @property
    def priority_class (self): return self._priority_class
    @priority_class.setter
    def priority_class (self, priority_class):
        self._priority_class = priority_class

    @property
    def hierarchy_class (self): return self._hierarchy_class
    @hierarchy_class.setter
    def hierarchy_class (self, hierarchy_class):
        self._hierarchy_class = hierarchy_class

    @property
    def hier_class (self):
        
        ''' Hierarchical ranking in the with-CADt world + hierarchical classes:
                1 if emergent patient
                3 onwards for each unique disease
                99 if AI negative
            In the without-CADt world, AI positive and negative have the
            same priority rank (in simulator.py).
        '''
        
        if self.is_interrupting: return priority_classes['interrupting']
        ## All AI-negative are assigned to the lowest class i.e. 99
        if not self.is_positive: return priority_classes['negative']
        
        # For all AIs that flagged the patient positive, get the corresponding
        # disease number. Return the smallest number (highest priority) from this list. 
        #all_flagged_pclasses = [hier_classes_dict[ii]['disease_num']
        #                        for ii in self._is_positives.keys()]
        return min ([self._hier_dict[ainame] for ainame in self._is_positives.keys()])

    def _get_interarrival_time (self):
        
        ''' Randomly generate the interarrival time from an exponential
            distribution at the arrival rate.
            
            output
            ------
            interarrival time (float): in minutes
        '''
        
        return numpy.random.exponential (1/self.arrivalRate) # minutes
        
    def add_close_time (self, close_time):
        
        ''' A patient image may be closed several times if it is opened
            by several radiologists. Each time it is opened, a close
            time is determined and pre-calculated based on the remaining
            reading time. This function appends this pre-calculated
            close time for record keeping and debugging purposes.
            
            Note that, if this patient was interrupted and has multiple
            close time, the previous close time may be beyond the current
            one. Instead of the previously calculated close time, the
            close time is updated.
            
            input
            -----
            close_time (pandas.datetime): the timestamp when this patient
                                          case is closed by the current
                                          radiologist
        '''
        
        # If this case isn't interrupted before, just append the close time.
        if len (self._close_times) == 0:
            self._close_times.append (close_time)
            return
        
        # Otherwise, remove any recorded close time before appending.
        for close in self._close_times:
            if close > close_time:
                self._close_times.remove (close)
        self._close_times.append (close_time)
        
    def add_doctor (self, doctor_name):
        
        ''' Whenever this patient is seen by a radiologist, the name of the
            radiologist is appended for record keeping. This was included
            for debugging purposes to make sure simulation is doing what is
            expected when handling lower-priority patients who get interrupted
            and may be seen by a different doctor next time around with
            multiple radiologists in the system.
            
            input
            -----
            doctor_name (str): the current doctor who opens this patient image
        '''
        
        self._doctors.append (doctor_name)
        